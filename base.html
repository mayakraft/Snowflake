<html>
<head>
<title></title>
<!--[if lt IE 9]>
    <script src="excanvas.js"></script>
<![endif]-->
<script src="jquery.min.js"></script>
</head>
<body>
<div style="position: relative;">
	<canvas id="simpleBases" width="600" height="400" style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
	<canvas id="simpleDraw" width="600" height="400" style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
</div>
<div style="position: relative;">
	<canvas id="hexagonResult" width="400" height="400" style="position: absolute; left: 600; top: 0; z-index: 0;"></canvas>
</div>
<script>

// DEFS
var sin60 = 0.866025403784439;
var twoPi = 6.28318530717959;
function Point(){
	var x;
	var y;
}

var baseCanvas = document.getElementById("simpleBases");
var baseContext = baseCanvas.getContext("2d");
var canvas = document.getElementById("simpleDraw");
var context = canvas.getContext("2d");
var hexCanvas = document.getElementById("hexagonResult");
var hexContext = hexCanvas.getContext("2d");

var mouse = new Point();  // in the computational space.  origin is the origin of the triangle

// triangle points:
// p1 origin
// p2 arm edge
// p3 top (hexagon side mid-point)
var p1 = new Point();
var p2 = new Point();
var p3 = new Point();
var radius = 300;

var o = new Point();
o.x = 100;
o.y = 250;

p1.x = 0;
p1.y = 0;
p2.x = p1.x+radius
p2.y = p1.y;
p3.x = p1.x+radius*.75;
p3.y = p1.y-radius*.5*sin60;

// triangle sides:
// b bottom (large radius)
// s outside side
// t top, (small radius)
var dB = new Point();  // begin from origin
var dS = new Point();  // from small radius to large
var dT = new Point();  // begin from origin

var bLength = Math.sqrt( (p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y) );
var sLength = Math.sqrt( (p2.x-p3.x)*(p2.x-p3.x) + (p2.y-p3.y)*(p2.y-p3.y) );
var tLength = Math.sqrt( (p3.x-p1.x)*(p3.x-p1.x) + (p3.y-p1.y)*(p3.y-p1.y) );
dB.x = (p2.x - p1.x) / bLength;
dB.y = (p2.y - p1.y) / bLength;
dS.x = (p3.x - p2.x) / sLength;
dS.y = (p3.y - p2.y) / sLength;
dT.x = (p3.x - p1.x) / tLength;
dT.y = (p3.y - p1.y) / tLength;

// RAYS from the mouse
var d1 = new Point();
var d2 = new Point();
d1.x = 1;
d1.y = 0;
d2.x = -.5;
d2.y = -sin60;

// 1/12 TRIANGLE SEGMENT
baseContext.lineWidth = 4;
baseContext.lineCap = "round";
baseContext.beginPath();
baseContext.moveTo(o.x + p1.x, o.y + p1.y);
baseContext.lineTo(o.x + p2.x, o.y + p2.y);
baseContext.lineTo(o.x + p3.x, o.y + p3.y);
baseContext.lineTo(o.x + p1.x, o.y + p1.y);
baseContext.stroke();

$(document).mousemove(function(event){
	mouse.x = event.pageX - o.x;
	mouse.y = event.pageY - o.y;
  // $("span").text(event.pageX + ", " + event.pageY);
  	canvas.width = canvas.width;
	context.lineWidth = 4;
	context.lineCap = "round";

	// POINT inside TRIANGLE test
	// http://stackoverflow.com/questions/13300904/determine-whether-point-lies-inside-triangle
	var alpha = ((p2.y - p3.y)*(mouse.x - p3.x) + (p3.x - p2.x)*(mouse.y - p3.y)) / ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));
	var beta = ((p3.y - p1.y)*(mouse.x - p3.x) + (p1.x - p3.x)*(mouse.y - p3.y)) / ((p2.y - p3.y)*(p1.x - p3.x) + (p3.x - p2.x)*(p1.y - p3.y));
	var gamma = 1.0 - alpha - beta;
	var inside = false;
	if(alpha > 0.0 && beta > 0.0 && gamma > 0.0){
		inside = true;
	}


	// RAY and LINE intersection test
	// http://rootllama.wordpress.com/2014/06/20/ray-line-segment-intersection-test-in-2d/
	var i1 = RayLineIntersectQuick(mouse, d1, p2, p3, sLength, dS);
	var i2 = RayLineIntersectQuick(mouse, d1, p1, p3, tLength, dT);
	var i3 = RayLineIntersectQuick(mouse, d2, p1, p3, tLength, dT);
	var i4 = RayLineIntersectQuick(mouse, d2, p1, p2, bLength, dB);

	var points = [];
	if(i4.x != undefined){
		points.push(i3);
		points.push(i4);
	}
	else if(i3.x != undefined){
		points.push(i3);
		points.push(mouse);
		points.push(i1);
		points.push(p2);
	}
	else if(i2.x != undefined){
		points.push(i2);
		points.push(i1);
		points.push(p2);
	}
	else{
		points.push(p2);
		points.push(p3);
	}
	context.fillStyle = "#E0E0E0";
	context.beginPath();
	context.moveTo(o.x + p1.x, o.y + p1.y);
	for(var i = 0; i < points.length; i++){
		context.lineTo(o.x + points[i].x, o.y + points[i].y);
	}
	context.lineTo(o.x + p1.x, o.y + p1.y);
	context.fill();

	context.fillStyle = "#22AA22";

	// if(inside) context.fillRect(mouse.x-10, mouse.y-10, 20, 20);
	// if(i1.x != undefined) context.fillRect(i1.x-10, i1.y-10, 20, 20);
	// if(i2.x != undefined) context.fillRect(i2.x-10, i2.y-10, 20, 20);	
	// if(i3.x != undefined) context.fillRect(i3.x-10, i3.y-10, 20, 20);
	// if(i4.x != undefined) context.fillRect(i4.x-10, i4.y-10, 20, 20);

	context.beginPath();
	context.moveTo(o.x + mouse.x, o.y + mouse.y);
	context.lineTo(o.x + mouse.x+radius*2*d1.x, o.y + mouse.y+radius*2*d1.y);
	context.moveTo(o.x + mouse.x, o.y + mouse.y);
	context.lineTo(o.x + mouse.x+radius*2*d2.x, o.y + mouse.y+radius*2*d2.y);
	context.stroke();

	var hex = new Point();
	hex.x = 200;
	hex.y = 200;

	var scale = .5;

  	hexCanvas.width = hexCanvas.width;
	hexContext.lineWidth = 4;
	hexContext.lineCap = "round";

	for(var a = 0; a < 6; a++){
		var angle = Math.atan2(points[0].y, points[0].x);// * 360 / 3.141592;
		var distance = Math.sqrt(points[0].y*points[0].y + points[0].x*points[0].x);
		hexContext.moveTo(hex.x + distance*Math.cos(angle+a*twoPi/6) * scale, hex.y + distance*Math.sin(angle+a*twoPi/6) * scale);
		for(var i = 1; i < points.length; i++){
			var angle = Math.atan2(points[i].y, points[i].x);// * 360 / 3.141592;
			var distance = Math.sqrt(points[i].y*points[i].y + points[i].x*points[i].x);
			hexContext.lineTo(hex.x + distance*Math.cos(angle+a*twoPi/6) * scale, hex.y + distance*Math.sin(angle+a*twoPi/6) * scale);
		}
	}
	// reflection
	for(var a = 0; a < 6; a++){
		var angle = Math.atan2(points[0].y, points[0].x);// * 360 / 3.141592;
		var distance = Math.sqrt(points[0].y*points[0].y + points[0].x*points[0].x);
		hexContext.moveTo(hex.x + distance*Math.cos(angle+a*twoPi/6) * scale, hex.y - distance*Math.sin(angle+a*twoPi/6) * scale);
		for(var i = 1; i < points.length; i++){
			var angle = Math.atan2(points[i].y, points[i].x);// * 360 / 3.141592;
			var distance = Math.sqrt(points[i].y*points[i].y + points[i].x*points[i].x);
			hexContext.lineTo(hex.x + distance*Math.cos(angle+a*twoPi/6) * scale, hex.y - distance*Math.sin(angle+a*twoPi/6) * scale);
		}
	}

	// hexContext.moveTo(hex.x+points[0].x*-scale, hex.y+points[0].y*-scale);
	// for(var i = 1; i < points.length; i++){
	// 	hexContext.lineTo(hex.x + points[i].x*-scale, hex.y + points[i].y*-scale);
	// }
	// hexContext.moveTo(hex.x+points[0].x*scale, hex.y+points[0].y*-scale);
	// for(var i = 1; i < points.length; i++){
	// 	hexContext.lineTo(hex.x + points[i].x*scale, hex.y + points[i].y*-scale);
	// }
	// hexContext.moveTo(hex.x+points[0].x*-scale, hex.y+points[0].y*scale);
	// for(var i = 1; i < points.length; i++){
	// 	hexContext.lineTo(hex.x + points[i].x*-scale, hex.y + points[i].y*scale);
	// }

	hexContext.stroke();
});

// origin and dX,dY of RAY -- pointA pointB of line
// pre-calculated length of AB, and dX dY of A->B
function RayLineIntersectQuick(origin, dV, pA, pB, lengthAB, dAB){
	var v1 = new Point();
	var v2 = new Point();
	var v3 = new Point();
	v1.x = origin.x - pA.x;
	v1.y = origin.y - pA.y;
	v2.x = pB.x - pA.x;
	v2.y = pB.y - pA.y;
	v3.x = -dV.y;
	v3.y = dV.x;
	var t1 = (v2.x*v1.y - v2.y*v1.x) / (v2.x*v3.x + v2.y*v3.y);
	var t2 = (v1.x*v3.x + v1.y*v3.y) / (v2.x*v3.x + v2.y*v3.y);
	var p = new Point();
	if(t2 > 0.0 && t2 < 1.0 && t1 > 0.0){
		p.x = pA.x + lengthAB * t2 * dAB.x;
		p.y = pA.y + lengthAB * t2 * dAB.y;
	}
	return p;
}

// full robust like gma's homemade chicken
// function RayLineIntersect(origin, dV, pA, pB){
// 	var v1 = new Point();
// 	var v2 = new Point();
// 	var v3 = new Point();
// 	v1.x = origin.x - pA.x;
// 	v1.y = origin.y - pA.y;
// 	v2.x = pB.x - pA.x;
// 	v2.y = pB.y - pA.y;
// 	v3.x = -dV.y;
// 	v3.y = dV.x;
// 	var t1 = (v2.x*v1.y - v2.y*v1.x) / (v2.x*v3.x + v2.y*v3.y);
// 	var t2 = (v1.x*v3.x + v1.y*v3.y) / (v2.x*v3.x + v2.y*v3.y);
// 	var p = new Point();
// 	if(t2 > 0.0 && t2 < 1.0 && t1 > 0.0){
// 		var dAB = new Point();
// 		var lengthAB = Math.sqrt( (pB.x-pA.x)*(pB.x-pA.x) + (pB.y-pA.y)*(pB.y-pA.y) );
// 		dAB.x = (pB.x - pA.x) / lengthAB;
// 		dAB.y = (pB.y - pA.y) / lengthAB;
// 		p.x = pA.x + lengthAB * t2 * dAB.x;
// 		p.y = pA.y + lengthAB * t2 * dAB.y;
// 	}
// 	return p;
// }
// canvas.onmousemove = mousePos;

// context.fillRect(10,10,100,100);
</script>
</html>